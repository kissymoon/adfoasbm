<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>25å•†è‹±1ç­å…±åŒç»˜ä½œ</title>
    <style>
        body { margin: 0; background: #050510; overflow: hidden; touch-action: none; font-family: sans-serif; }
        canvas { position: absolute; top: 0; left: 0; }
        .toolbar {
            position: relative;
            background: rgba(255, 255, 255, 0.05);
            backdrop-filter: blur(15px);
            padding: 12px 20px;
            z-index: 100;
            display: flex;
            gap: 20px;
            align-items: center;
            color: rgba(255,255,255,0.8);
            border-bottom: 1px solid rgba(255,255,255,0.1);
        }
        #status { font-weight: bold; font-size: 0.9em; }
        .debug-btn { 
            background: rgba(255, 71, 87, 0.2); 
            color: #ff4757; 
            border: 1px solid #ff4757; 
            padding: 4px 12px; 
            border-radius: 20px; 
            cursor: pointer;
            transition: 0.3s;
            font-size: 0.8em;
        }
        .debug-btn:hover { background: #ff4757; color: white; }
    </style>
</head>
<body>

    <div class="toolbar">
        <strong>25å•†è‹±1ç­å…±åŒç»˜ä½œ</strong>
        <span id="status">è¿æ¥ä¸­...</span>
    </div>

    <canvas id="bgCanvas"></canvas>
    <canvas id="canvas"></canvas>

    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>

    <script>
        const SUPABASE_URL = '';
        const SUPABASE_KEY = '';
        const supabaseClient = supabase.createClient(SUPABASE_URL, SUPABASE_KEY);

        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const bgCanvas = document.getElementById('bgCanvas');
        const bgCtx = bgCanvas.getContext('2d');
        const statusEl = document.getElementById('status');

        let particles = [];
        let currentStroke = []; 
        let isDrawing = false;
        
        // --- æ ¸å¿ƒä¿®æ”¹ï¼šæ¯ä¸ªäººè¿›æ¥éšæœºä¸€ä¸ªé¢œè‰²èµ·ç‚¹ ---
        let myBaseHue = Math.random() * 360; 
        let currentHue = myBaseHue; 

        let hasDrawn = localStorage.getItem('user_has_drawn_stardust') === 'true';

        function init() {
            canvas.width = bgCanvas.width = window.innerWidth;
            canvas.height = bgCanvas.height = window.innerHeight;
            bgCtx.fillStyle = '#050510';
            bgCtx.fillRect(0, 0, bgCanvas.width, bgCanvas.height);
            updateStatusUI();
        }

        class Particle {
            constructor(x, y, hue, isPermanent = false) {
                this.x = x;
                this.y = y;
                this.hue = hue;
                this.size = Math.random() * 2 + 0.5;
                this.life = 1.0;
                this.decay = Math.random() * 0.015 + 0.01;
                this.vx = (Math.random() - 0.5) * 0.8;
                this.vy = (Math.random() - 0.5) * 0.8;
                this.isPermanent = isPermanent;
            }

            update() {
                this.x += this.vx;
                this.y += this.vy;
                this.life -= this.decay;
            }

            draw(targetCtx, centerX, centerY, count) {
                for (let i = 0; i < count; i++) {
                    targetCtx.save();
                    targetCtx.translate(centerX, centerY);
                    targetCtx.rotate((Math.PI * 2 / count) * i);
                    
                    const drawX = this.x - centerX;
                    const drawY = this.y - centerY;

                    // å£ç”»è½¨è¿¹é€æ˜åº¦è¾ƒä½ï¼Œäº§ç”Ÿå †å æ„Ÿï¼›åŠ¨æ€ç²’å­è¾ƒäº®
                    targetCtx.globalAlpha = this.isPermanent ? 0.2 : this.life;
                    targetCtx.beginPath();
                    targetCtx.arc(drawX, drawY, this.size, 0, Math.PI * 2);
                    targetCtx.fillStyle = `hsla(${this.hue}, 85%, 75%, ${this.life})`;
                    
                    if(!this.isPermanent) {
                        targetCtx.shadowBlur = 12;
                        targetCtx.shadowColor = `hsla(${this.hue}, 80%, 70%, 0.8)`;
                    }
                    
                    targetCtx.fill();
                    targetCtx.restore();
                }
            }
        }

        const channel = supabaseClient.channel('drawing_room');

        channel.on('broadcast', { event: 'draw_stardust' }, (payload) => {
            const { points, startHue } = payload.payload;
            renderRemoteStroke(points, startHue);
        }).subscribe((status) => {
            if (status === 'SUBSCRIBED') updateStatusUI();
        });

        // æ¸²æŸ“ä»–äººçš„ç¬”è§¦
        function renderRemoteStroke(points, startHue) {
            let tempHue = startHue;
            points.forEach(p => {
                for(let i=0; i<1; i++) {
                    const part = new Particle(p.x, p.y, tempHue, true);
                    particles.push(part);
                    part.draw(bgCtx, bgCanvas.width/2, bgCanvas.height/2, 8);
                }
                tempHue += 0.2;
            });
        }

        function animate() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            for (let i = particles.length - 1; i >= 0; i--) {
                particles[i].update();
                particles[i].draw(ctx, canvas.width / 2, canvas.height / 2, 8);
                if (particles[i].life <= 0) particles.splice(i, 1);
            }
            requestAnimationFrame(animate);
        }

        function createParticles(x, y) {
            if (!isDrawing || hasDrawn) return;
            
            currentStroke.push({x, y});
            
            for(let i=0; i<2; i++) {
                const p = new Particle(x, y, currentHue, true);
                particles.push(p);
                p.draw(bgCtx, bgCanvas.width/2, bgCanvas.height/2, 8);
            }
            currentHue += 0.2; // åŒä¸€ç¬”å†…é¢œè‰²æ¸å˜
        }

        function handleStart(e) {
            if (hasDrawn) return;
            isDrawing = true;
            currentStroke = [];
            // æ¯æ¬¡æ–°çš„ä¸€ç¬”å¯ä»¥é‡æ–°éšä¸€ä¸ªè‰²ç›¸ï¼Œæˆ–è€…æ²¿ç”¨ä¹‹å‰çš„è‰²ç›¸
            // è¿™é‡Œæˆ‘ä»¬è®©æ¯ç¬”å¼€å§‹æ—¶çš„è‰²ç›¸ç¨å¾®è·³è·ƒä¸€ç‚¹ç‚¹ï¼Œå¢åŠ å¤šæ ·æ€§
            currentHue = myBaseHue + (Math.random() * 30 - 15); 
            const x = e.clientX || (e.touches && e.touches[0].clientX);
            const y = e.clientY || (e.touches && e.touches[0].clientY);
            createParticles(x, y);
        }

        function handleEnd() {
            if (isDrawing) {
                isDrawing = false;
                hasDrawn = true;
                localStorage.setItem('user_has_drawn_stardust', 'true');
                updateStatusUI();

                // å¹¿æ’­è¿™æ•´ç¬”çš„è½¨è¿¹å’Œé¢œè‰²èµ·ç‚¹
                channel.send({
                    type: 'broadcast',
                    event: 'draw_stardust',
                    payload: { 
                        points: currentStroke, 
                        startHue: currentHue - (currentStroke.length * 0.2) 
                    }
                });
            }
        }

        function updateStatusUI() {
            if (hasDrawn) {
                statusEl.innerText = 'ğŸš« ç•™å¢¨å®Œæˆ';
                statusEl.style.color = '#ff4757';
            } else {
                statusEl.innerText = 'ğŸŸ¢ è¯·æŒ¥æ´’æ˜Ÿå°˜';
                statusEl.style.color = '#2ecc71';
            }
        }

        function resetLimit() {
            localStorage.removeItem('user_has_drawn_stardust');
            hasDrawn = false;
            // é‡ç½®èƒŒæ™¯é¢œè‰²ï¼Œæ¸…ç©ºç”»å¸ƒ
            bgCtx.fillStyle = '#050510';
            bgCtx.fillRect(0, 0, bgCanvas.width, bgCanvas.height);
            myBaseHue = Math.random() * 360; // é‡ç½®æ—¶ä¹Ÿæ¢ä¸ªä¸»è‰²è°ƒ
            updateStatusUI();
        }

        canvas.addEventListener('mousedown', handleStart);
        window.addEventListener('mouseup', handleEnd);
        canvas.addEventListener('mousemove', (e) => createParticles(e.clientX, e.clientY));
        canvas.addEventListener('touchstart', (e) => { handleStart(e); e.preventDefault(); }, { passive: false });
        canvas.addEventListener('touchmove', (e) => { 
            const t = e.touches[0];
            createParticles(t.clientX, t.clientY); 
            e.preventDefault(); 
        }, { passive: false });
        canvas.addEventListener('touchend', handleEnd);

        init();
        animate();
        window.addEventListener('resize', init);
    </script>
</body>
</html>

